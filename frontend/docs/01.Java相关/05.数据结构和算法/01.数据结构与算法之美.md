---
title: 数据结构与算法之美
date: 2020-06-12 18:16:18
permalink: /pages/50ad24/
categories: 
  - 数据结构和算法
tags: 
  - 
---
1. 函数体内的局部变量存在栈上，且是连续压栈，既先声明并赋值的变量在最下面，在linux进程的栈内存布局中，栈区在高地址空间，从高到低增长(使用)

2.  线程池没有空闲可用线程处理任务时，一般采用两种策略:

   1. 一种是阻塞等待：任务请求排队，等到有空闲可用线程时，按照先来先得的顺序获取线程资源，队列这个数据结构就是用来存储任务请求的，队列同时有两种实现方式，采用链表实现的方式，队列的长度可以无限长（取决于内存大小),这样实现的队列就是一个无界队列，这种队列的缺点是会导致过多的任务请求排队在队列中，请求响应时间可能会很长，不适合对响应实时性有要求的场景，采用数组实现的方式，队列长度固定，这就是一个有界队列，有界队列的缺点是当队列满载时，后续的请求可能会被抛弃。
   2. 一种是非阻塞：直接拒绝.

<!-- more -->

3. 一致性hash算法：http://www.zsythink.net/archives/1182

4. 二叉查找树（二叉搜索树，也叫二叉排序树）：左边子节点的值小于父节点，右子树节点的值大于父节点。

   * 实际中每个节点存储的是对象，使用每个对象的某个字段作为key值来构建这颗树，对象中其他字段叫做卫星数据。

   * 相比于散列表的优势是二叉查找树中的数据可以采用中序遍历，在O（n）时间内输出有序数据，而散列表是无序的,且散列表有扩容和缩容的问题，性能没有平衡二叉查找树稳定(O(logn))。

   * 二叉查找树在查找，删除和新增的时间复杂度和树的高度成正比，极端情况下退化成链表，时间复杂度为0（n）,

     最好情况下是完全二叉树,时间复杂度为O（logn）。

   满二叉树：除了叶子节点外，每个节点都有左右两个节点

   完全二叉树：除叶子节点层，其它层个数达到最大，叶子节点层的节点都靠左排列

   平衡二叉查找树：二叉树中任意一个节点的左右子树的高度相差不能大于1	

   * **红黑树**（平衡二叉查找树的一种）：
     * 1）根节点是黑色的
     * 2）每个叶子节点都是黑色的空节点（NULL）叶子节点不存储数据。
     * 3）任何相邻的节点都不能同时为红色，红色节点是被黑色节点分割开来的。
     * 4）每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。

   * 使用场景：解决普通二叉查找树在动态更新的过程当中，复杂度退化问题而产生的，他的高度近似2log2n 约等于 	log2n，所以红黑树是一种近似平衡的树，因为近似平衡，相应的性能就比较稳定0(logn)

   * 插入：插入的节点必须是红色的，二叉查找树插入新节点都是在叶子节点上(

     	1. 如果插入节点的父亲节点是黑色的，则该节点直接插入即可，满足红黑树的定义。
      	2. 插入根节点，直接根节点变黑色即可,也满足红黑树的定义）

     * 围绕X节点的左旋：将X节点下移到其左子节点位置，X节点的右子节点上移到X节点原来的位置，现X节点的左子节点不动，将原X节点的右子节点的左子节点附着在现X节点的右子节点位置，原X节点的右子节点的右子节点不动，变换完毕
     * 围绕X节点的右旋：将X节点下移到其右子节点位置，X节点的左子节点上移到X节点原来的位置，现X节点的右子节点不动，将原X节点的左子节点的右子节点附着在现X节点的左子节点位置，原X节点的左子节点的左子节点不动，变换完毕

   5. 堆：一种完全二叉树，底层实现使用数组实现，分为大顶堆和小顶堆，堆排序是一种不稳定的排序，堆排序相比于快速排序，虽然时间复杂度都是O(nlog n)，但是堆排序过程遍历元素是跳跃式的，快速排序元素之间比较遍历是顺序式的。跳跃式的遍历在数组中对CPU缓存是不友好的。且堆排序比快速排序的交换次数多。
   
   * 堆如果使用数组存储，从下标1开始存储，则其左子节点为2\*i,右子节点为2\*i+1,数组的长度是堆中所有元素和+1，因为下标从1开始存储的。对于完全二叉树，其从n/2+1到n都是叶子节点，之前的1到n/2都非叶子节点，n是数组的长度(可用反证法证明)
   
   * 堆的应用：
        * 优先级队列（高性能定时器，将很多定时任务按照时间远近组成堆，定时器获取这个队列中的堆顶元素去执行任务，然后执行下一个堆顶元素任务）。
     * TopK问题：维护一个K长度的小顶堆，遍历数组，当数组中的值大于堆顶元素，则删除堆顶元素，并将该元素插入这个小顶堆，这个小顶堆可以一直维护，当数组新插入数据的时候，可以和栈顶比较，从而实现了非静态类型的TopK实现。
        * 使用堆求中位数：对于静态数据容器，在排序后，中位数的位置是固定的，既n/2,对于动态数据容器，每次取中位数都得排序，成本较高，可以使用两个堆，一个大顶堆，一个小顶堆，大顶堆存储前半部分数据（n是偶数：元素数量等于2/n,n是奇书：元素数量等于n/2+1），小顶堆存储后半部分数据(n是偶数：元素数量等于2/n,n是奇书：元素数量等于n/2)，且小顶堆中的数据都大于大顶堆中的数据，当插入一个新数据时候，如果插入数据大于等于小顶堆的堆顶，则插入小顶堆,否则则插入大顶堆，然后再计算这两个堆的元素数量是否符合这两个堆的数量的定义，如果不符合，则要移动堆顶元素到另一个堆中。

      

   6. 图：非线性表数据结构，图中的元素我们叫做顶点。顶点和顶点之间建立的联系叫做边。一个顶点有多少个边，就是这个顶点的度。有向图中有出度和入读这两种度，无向图有带权图的类型、
      * 图可以使用邻接矩阵进行存储，而邻接矩阵的实现是一个二维数组，
      * 图也可以使用邻接表进行存储，邻接表的实现是一个数组+链表的方式。
   
   7. BM算法：
      
   8. 贪心算法：
   
      * 哈夫曼编码：对数据的压缩编码，有效节省存储空间：
      * 如何构造哈夫曼树，计算出每个字符的编码：首先统计出每个字符的出现频率，然后按照频率从小到大的顺序将这些字符放入一个优先级队列中，所有字符和其频率入队以后，从队列头部就可以拿出最小的两个频率的字符a,b，将这两个字符的频率叠加，得到一个X字符，且这个X字符为a,b两个字符的父节点，然后将这个字符放入优先级队列中，继续重复上述步骤，直至优先级队列中没有一个字符为止。构造完成哈夫曼树以后，我们给这个数的每一条边加上一个权值，指向左子节点的边标记为0，指向右子节点的边标记为1.则从根节点到叶子节点的路径就是每个对应字符的哈夫曼编码
   
      
   
   9. 分治算法：
   
      * 分而治之，也就是将原问题分解成n个规模较小的，但是这些子问题不能有重复的，递归的解决这些与原问题相似的子问题，然后再合并结果
      * 分治算法是一种处理问题的思想，递归是一种编程技巧，
      * n个数据，完全有序从小到大排列的有序度就是n*(n-1)/2,逆序度等于0
   
   10. 回溯算法：
   
       * 类似枚举搜索，我们枚举所有的的解，找到满足期望的解，把问题求解的过程分为多个阶段，每个阶段都会面临一个岔路口，我们先随意选择一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上个岔路口，选择另外一种走法继续走
       * 八皇后问题：8*8的棋盘，希望在上面放置8个棋子（皇后），每个棋子所在的行，列，对角线都不能有另一个棋子，找到所有满足上述条件的放置方案，解决方法是：把这个问题分解成8个阶段，依次将8个棋子放在第一行，第二行，第三行，，，第八行，在每次放置前，检查放置的位置是否满足约束提交，若满足，则递归进行下一次的若不满足，则更换位置。
   
   11. 动态规划：
   
       * 0_1 背包问题
       * 一个模型：多阶段决策最优解模型：动态规划用来解决最优解问题，而解决问题的过程，需要经历多个决策阶段，每个决策阶段都对应着一组状态，我们寻找一组决策序列,这组决策序列就是我们要找的最优解序列、
       * 三个阶段
         1. 最优子结构：问题的最优解包含子问题的最优解，我们可以子问题的最优解推导出问题的最优解，既多阶段模型中，后阶段的状态可以通过前面阶段的状态推导出啦。
         2. 无后效性：再推导后面阶段的状态的时候，我们只关心上一阶段的状态，而不关心上一阶段的状态是怎么推导过来的，某阶段状态一旦确定，就不受之后阶段的影响
         3. 重复子问题：不同的决策序列，在到达某一阶段的时候，可能会出现重复状态
       * 两种实现思路，状态转移表法：画出当前状态的推导过程表，就能确定代码实现方式。状态转移方程：某个问题可以通过子问题来递归求解，也就是寻找最优子结构，根据最优子结构，写出递归方程，有了递归方程就可以递归+备忘录或者迭代递归的方式实现代码。
       
       四种算法的比较：贪心，动态规划，回溯，分治，分治算法不能抽象成多阶段决策模型，其他三个可以，回溯算法基本上贪心和动态规划能解决的也能解决，穷举搜索，不过他是指数级别的，使用小规模数据的场景上比较好。动态规划和回溯算法的区别在于，回溯算法中存在大量重复子问题，所以效率比动态规划较低。但是动态规划不是万能的，需要满足三个阶段的要求才能使用，贪心算法实际上动态规划的一种特殊情况，它需要满足三个条件：最优子结构，无后效性，贪心选择性（通过局部最优的选择，能产生全局的最优选择，每一个阶段，我们都选择看起来最优的决策，所有决策完成之后，最终由这些局部最优解构成全局最优解）
       
   12. 拓扑排序：有向无环图