---
title: 数据结构与算法之美
date: 2020-06-12 18:16:18
permalink: /pages/50ad24/
categories: 
  - 数据结构和算法
tags: 
  - 
---
1. 函数体内的局部变量存在栈上，且是连续压栈，既先声明并赋值的变量在最下面，在linux进程的栈内存布局中，栈区在高地址空间，从高到低增长(使用)

2.  线程池没有空闲可用线程处理任务时，一般采用两种策略:

   1. 一种是阻塞等待：任务请求排队，等到有空闲可用线程时，按照先来先得的顺序获取线程资源，队列这个数据结构就是用来存储任务请求的，队列同时有两种实现方式，采用链表实现的方式，队列的长度可以无限长（取决于内存大小),这样实现的队列就是一个无界队列，这种队列的缺点是会导致过多的任务请求排队在队列中，请求响应时间可能会很长，不适合对响应实时性有要求的场景，采用数组实现的方式，队列长度固定，这就是一个有界队列，有界队列的缺点是当队列满载时，后续的请求可能会被抛弃。
   2. 一种是非阻塞：直接拒绝.

<!-- more -->
3. 一致性hash算法：http://www.zsythink.net/archives/1182

4. 二叉查找树（二叉搜索树，也叫二叉排序树）：左边子节点的值小于父节点，右子树节点的值大于父节点。

   * 实际中每个节点存储的是对象，使用每个对象的某个字段作为key值来构建这颗树，对象中其他字段叫做卫星数据。

   * 相比于散列表的优势是二叉查找树中的数据可以采用中序遍历，在O（n）时间内输出有序数据，而散列表是无序的,且散列表有扩容和缩容的问题，性能没有平衡二叉查找树稳定(O(logn))。

   * 二叉查找树在查找，删除和新增的时间复杂度和树的高度成正比，极端情况下退化成链表，时间复杂度为0（n）,

     最好情况下是完全二叉树,时间复杂度为O（logn）。

   满二叉树：除了叶子节点外，每个节点都有左右两个节点

   完全二叉树：除叶子节点层，其它层个数达到最大，叶子节点层的节点都靠左排列

   平衡二叉查找树：二叉树中任意一个节点的左右子树的高度相差不能大于1	

   * **红黑树**（平衡二叉查找树的一种）：
     * 1）根节点是黑色的
     * 2）每个叶子节点都是黑色的空节点（NULL）叶子节点不存储数据。
     * 3）任何相邻的节点都不能同时为红色，红色节点是被黑色节点分割开来的。
     * 4）每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。

   * 使用场景：解决普通二叉查找树在动态更新的过程当中，复杂度退化问题而产生的，他的高度近似2log2n 约等于 	log2n，所以红黑树是一种近似平衡的树，因为近似平衡，相应的性能就比较稳定0(logn)

   * 插入：插入的节点必须是红色的，二叉查找树插入新节点都是在叶子节点上(

     	1. 如果插入节点的父亲节点是黑色的，则该节点直接插入即可，满足红黑树的定义。
      	2. 插入根节点，直接根节点变黑色即可,也满足红黑树的定义）

     * 围绕X节点的左旋：将X节点下移到其左子节点位置，X节点的右子节点上移到X节点原来的位置，现X节点的左子节点不动，将原X节点的右子节点的左子节点附着在现X节点的右子节点位置，原X节点的右子节点的右子节点不动，变换完毕
     * 围绕X节点的右旋：将X节点下移到其右子节点位置，X节点的左子节点上移到X节点原来的位置，现X节点的右子节点不动，将原X节点的左子节点的右子节点附着在现X节点的左子节点位置，原X节点的左子节点的左子节点不动，变换完毕

   5. 堆：堆是一个完全二叉树，堆中每一节点的值都必须大于等于其子树中每一个节点的值
   6. 

   

   

   

   

   