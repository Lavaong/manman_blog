#### 索引相关 ####

1. Innodb引擎实现索引的数据结构: 平衡N叉搜索树（B+树）

   * 表都是根据主键顺序以索引的形式存放的：索引组织表
   * 每一个索引对应一个B+树
   * 主键索引(聚簇索引)叶子节点的数据结构是页（每个页的默认大小是16KB,页中存储的是行，页是有一个有序数组结构，通过二分法查找行）
   * 非主键索引(二级索引)中叶子节点存储的是主键的值。
   * 普通索引不同于唯一索引，普通索引会使用change buffer 记录更新操作,change buffer可以使更新操作的随机读IO变成顺序读IO(定时将更新的值持久化到磁盘上，或下一次查询该记录的时候更新值到内存中的页上)，而唯一索引不会使用change buffer 进行更新操作，故会加大随机IO,但是唯一索引不会进行多余的查找，因为唯一性。使用场景：读少写多的场景推荐普通索引+change buffer 的使用方式
   * 重建普通索引可以紧凑空间，提高利用率，方法是先alter table  t drop index xxx，再add 索引 alter table t add index (xxx)。但是重建主键索引不能使用这种方式 alter table t drop primary xxx,alter table t add primary (xxx),不论是drop主键还是add主键都会导致将整个表重建，所以正确的重建主键索引的做法是：alter table t engine=Innodb。另外drop主键索引会导致其他索引失效，但drop普通索引不会

   * 由于覆盖索引可以减少树的搜索次数，显著提升性能，减少回表次数，直接在该索引中查找到我们的结果，故效率比较高。
   * 索引最左前缀原则：指的是复合索引中，如果查询的条件是最左边的N个索引字段或者字符串索引的最左边N个字符，则会走索引。
   * 索引下推优化：Mysql5.6以后，复合索引中，可以在索引遍历过程中，对复合索引中包含的字段先做判断，直接过滤掉不符合条件的索引选项，减少回表次数。

#### 锁相关 ####

1. 全局锁: Flush tables with read lock 此命令会让整个数据库处于只读状态，一般用于全库逻辑备份，之后更新语句和更新表结构语句都会被阻塞，直到全局锁被放开 （断开客户端连接会自动放开）

2. 表级锁:

   * local tables xxx read/write ,会限制执行该命令的线程只读或者只写，其他线程对于限制的操作(读或者写)处于阻塞状态，表级锁只在数据库引擎不支持行级锁和事务的情况下才会用到，一般情况使用的都是行级锁

   * MDL锁：没有显示的加锁命令，在访问一个表的时会被自动加上，直到事务提交才会被释放。作用是当对一个表做增删改查操作时候，表会自动加上读锁，当对一个表做表结构变更的时候，表自动加写锁
     * 读锁之间不互斥，这意味着可以很多线程对同一张表进行增删改查
     * 写锁之间，读/写之间互斥，这意味着当有一个线程做表结构变更的时候，其他线程不可对表进行表结构变更和增删改查

3. 行级锁：在innodb中，行锁是需要时加上（更新行时），但是释放得等事务结束才能释放--两阶段锁协议

   * 死锁现象：处在不同事务中的sql互相等待另一个事务中释放它需要的行锁，循环等待，就会造成死锁，死锁一般是等待超时（默认50s）自动退出或者进行死锁检测，主动回滚造成死锁的事务。业务上一般采用主动死锁检测，但是当同一多行数据被锁时，后续对这多行的并发更新操作事务都会导致进行死锁检测，查看是否是自己导致的死锁，以至于出现很高的CPU消耗在检测时间上。解决方式是:控制数据库服务端的并发度，在进入服务端之前使用数据库中间件进行排队等待，将并发度控制在一个较低的级别。或者将并发度比较高的热点记录分放在多行，更新热点记录行的时候随机选择一个子行进行更新，然后查询时候汇总所有子行的记录值，但是需要考虑子行的记录变成0的情况需要做特殊处理。

#### 事务和锁 ####

1. Mysql有两种视图：

   * view 查询语句定义的虚拟表，在调用的时候执行查询语句并生成虚拟表，也称为视图

   * consistent read view(InnoDB在实现MVCC时用到的一致性读视图),用于支持读提交,可重复提交隔离级别的实现，具体就是在事务隔离期间，定义了我能看到什么数据。

     * **一致性读**：事务中查询数据时使用一致性读，一致性读会根据当前事务中行的row_tx_id和当前事务的一致性视图数组来确定数据版本的可见性，一致性读视图数组定义：当开启一个事务的瞬间，先于该事务开启的是活跃的事务，会被加入到该数组中。对于一个事务中的**一致性读**视图数组来说，除了在当前事务中自己的更新总是可见外，有以下三种情况

     1. 版本未提交，不可见
     2. 版本已提交，但在视图创建之后提交的，不可见
     3. 版本已提交，但在视图创建之前提交的，可见

   * **当前读**：事务更新数据时或者事务中使用的查询语句加锁时（select * from t where id = 1 for update  或者 select * from t where id = 1 lock in share mode,加上 for update表示使用了排他锁-X锁，加上locak in share mode表示使用了共享锁-S锁）只能使用**当前读**，读到当前最新数据版本的数据，然后再写入更新数据。如果当前最新版本的数据还没有提交，意味着这行数据是被上锁的，需等待释放行锁以后才能进行更新。

2. 当内存数据页跟磁盘数据页内容不一致的时候，我们称呼这个内存页为脏页，内存数据页写入到磁盘后，内存和磁盘上的内容一致了，称呼这个内存页为干净页。

3. innodb_file_per_table:表数据存放在系统表空间还是.ibd文件中的参数，设置为on表示存放在.ibd文件中，建议设置为on,这样，删除表数据的时候，会连带删除该文件，达到释放空间的目的，删除整个表的命令： drop table xxx。

   * 当使用delete命令来删除某些行的时候，在Innodb引擎中并不会实际删除行所在数据页的空间，而是把该数据页标记为可复用，当整个页删除一些记录，还存在记录的时候，如果插入一个新纪录在这个页被删除的记录的范围内，则这个页的这些个空间可以被拿来复用，当整个页都没有行记录的时候或者相邻两个页的数据页利用率较小，系统会把两个页的数据合并到一个页上，然后将另一个页标记为可复用，整个页就可以被拿来记录使用新页的新纪录去使用

   * 插入记录和更新记录可能造成记录所在页出现空洞，为保持B+树有序，新插入的记录或者更新的记录会被导致重新分配页，原来的页就会出现空洞。如果可以去除空洞，就能达到收缩表空间的目的。
   * alter table t engine = InnoDB ：(recreate)该命令会重建表，将原表中分散的索引行重新插入一遍，处理掉了空洞的问题，MySQL5.6 之前，这个操作的隐含选项是将原来的表copy到临时表中，然后交换表名，删除原表，这个过程是需要暂停原表的更新的，所以这个操作不是online的,既不支持实时。5.6之后，这个命令的隐含算法实现是将原表所有数据页生成的B+树，存储到一个临时文件中，同时也把对原表的操作记录在一个row log日志文件中，待对原表的扫描完成，再将日志文件中的操作应用到临时文件中，然后替换原表表名，删除原表，所以这个操作是online的，且是inplace的（没有把数据移动到另一个表中）。
   * analyze table t：对表的索引信息做重新统计，会加MDL读锁
   * optimize table t : 相当于重建表命令和重新统计索引信息命令的结合、

   

4. order by rand() 使用了内存临时表，内存临时表排序的时候使用了sort buffer 和 rowid 排序的方法。

5. floor(x),返回小于等于x的最小整数，rand(),返回[0,1)之间的随机小数、

6. 对索引字段使用显示函数或者隐式函数可能会破坏索引值的有序性，导致索引失效，优化器会放弃走树搜索(兄弟节点的有序性，精准定位)，既会全记录扫描，即使函数不会导致行记录的有序性发生改变，优化器也会偷懒的选择不走索引。

   * 隐式函数一般是数据类型转换或者字符编码转换，在Mysql中，String 和 int 的隐式转换是把String 转换为int，字符编码转换向数据长度增加的方向转换，为避免截断数据导致的数据丢失，如utf8mb4是utf8的超集，故默认会将utf8编码的字段转换为utf8mb4类型后再进行比较。

7. 幻读：一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行（仅仅指其他事务新插入的行）

   间隙锁：锁的是两个值之间的空隙，间隙锁会发生冲突当往间隙中插入数据时、两个事务对一个区间间隙锁同时加锁不会发生冲突，当查询命中表中的数据时且使用了X（for update）锁，则会锁住命中行的前后行之间的next-key lock 范围（前开后闭）的更新（行锁，等待释放X锁）和插入事件(间隙锁)，当查询未命中时且使用了X锁，则只会锁住查询条件所在范围的间隙锁，阻止其他事务的插入事件。